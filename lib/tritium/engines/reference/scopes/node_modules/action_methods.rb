module Tritium::Engines::Reference::Scope
  module NodeModules 
    module ActionMethods
      def insert_tag(tag_name, contents = "", attributes = {}, &block)
        if contents.is_a? Hash
          attributes = contents
          contents = ""
        end

        new_node = position_node(node, "<#{tag_name} />").first
        (new_node.inner_html = contents) if contents.size > 0
    
        # Merge doesn't work here, so we have to iterate... bullshit!
        attributes.each do |key, value|
          new_node.set_attribute(key.to_s, value.to_s) 
        end

        if block
          Tritium::Engines::Reference::Scope::Node.new(new_node, @root, self).instance_eval(&block)
        end
      end

      def inject(html, &block)
        result = position_node(node, html)
        if result.respond_to?("first")
          result = result.first
        end
        if block
          Tritium::Engines::Reference::Scope::Node.new(result, @root, self).instance_eval(&block)
        end
      end
      alias insert inject
  
      def name(new_name = nil, &block)
        if new_name
          node.name = new_name
        end
        if block
          node.name = open_text_scope_with(node.name, &block)
        end
      end

      def remove
        @node.remove
      end
      
      def wrap(tag_name, attributes = {}, &block)
        wrap_node = @node.add_previous_sibling("<#{tag_name} />").first
        attributes.each do |key,val|
          if key.is_a? Symbol
            key = key.to_s
          end
          wrap_node[key] = val
        end
        wrap_node.add_child(@node)

        if block
          Tritium::Engines::Reference::Scope::Node.new(wrap_node, @root, self).instance_eval(&block)
        end
      end

      def wrap_text_children(tag_name, attributes = {}, &block)
        @node.children.each do |child|
          next if not child.text? or child.text.strip.empty?
          wrapper = child.add_previous_sibling("<#{tag_name} />").first
          attributes.each do |key, val|
            key = key.to_s if key.is_a? Symbol
            wrapper[key] = val
          end
          wrapper.add_child(child)
          
          if block
            Tritium::Engines::Reference::Scope::Node.new(wrapper, @root, self).instance_eval(&block)
          end
        end
      end
      
      def inner_wrap(tag_name, attributes = {}, &block)
        wrap_node = @node.add_child("<#{tag_name} />").first

        attributes.each do |key,val|
          if key.is_a? Symbol
            key = key.to_s
          end
          wrap_node[key] = val
        end
        @node.children.each do |child|
          if child != wrap_node
            wrap_node.add_child(child)
          end
        end

        if block
          Tritium::Engines::Reference::Scope::Node.new(wrap_node, @root, self).instance_eval(&block)
        end
      end

      def move_to(selector, position = "bottom", &block)
        to = node.xpath(selector).first
        return if to.nil?
        
        position_node(to, node, position)
        
        if block
          Tritium::Engines::Reference::Scope::Node.new(to, @root, self).instance_eval(&block)
        end
      end
      
      def move_here(selector, position = "bottom", &block)
        move(selector, node, position, &block)
      end
      
      def move(what, to, position, &block)
        
        if what.is_a?(String)
          what = node.xpath(what)
        end
        
        if to.is_a?(String)
          to = node.xpath(to)
        end
        
        to = [to].flatten
        what = [what].flatten
        
        to.each do |to_target|
          what.each do |what_target|
            position_node(to_target, what_target, position)
            
            if block
              Tritium::Engines::Reference::Scope::Node.new(what_target, @root, self).instance_eval(&block)
            end
          end
        end
      end
      
      def copy_to(selector, position = "bottom", &block)
        move(node.dup, selector, position, &block)
      end
      
      def copy_here(selector, position = "bottom", &block)
        target = node.xpath(selector).first
        if target
          move(target.dup, node, position, &block)
        end
      end
    end
  end
end

#!/usr/bin/env ruby

require "optparse"
#require "ruby-debug"

OptionParser.new do |opts|
  opts.banner = "Usage: ts2func-ruby filename.ts filename.to"
end.parse!


files = {}
files[:input] = ARGV[0] || ""
files[:output] = ARGV[1] || ""

require "beefcake"
require_relative '../lib/tritium'
require_relative '../lib/tritium/serializer/serializer'

def parse_name(raw_function) 

  parens_index = raw_function.index("(")

  name = raw_function[0..parens_index-1].strip
  raw_function = raw_function[parens_index..-1]

  [raw_function, name]
end

def parse_args(raw_function) 

  args_begin = raw_function.index("(")
  args_end = raw_function.index(")", args_begin)
  
  args = raw_function[args_begin+1..args_end-1]
  raw_function = raw_function[args_end+1..-1]  

  # Do I need to keep anything beyond the type?

  args = args.split(",").collect do |arg_string|
    arg = ::Function::Argument.new 
    arg.type_id = arg_string.split(" ").first
  end
  
  args.compact!

  [raw_function, args]
end

def get_function_signature(function)

  signature = function.name
  
  function.args.each do |arg|
    signature << "." << arg
  end

  signature
end

def parse_function(tritium, signature)

  # Get the function body without the curly brackets:

  block_start = tritium.index("{")
  block_end = tritium.index(/\}\s*?\Z/)

  block = tritium[block_start+1..block_end-1]

  ## Hack to fix %function_variables_like_this

  block.gsub!(/\%(\w*?\W)/, "$function_\\1")

  # Now stuff the body into a tmp file so that I can re-use the ObjectSerializer
  
  temp_filename = signature + ".tmp"
  File.open(temp_filename, "w") {|f| f << block}

  instructions = Tritium::Serializer::ObjectSerializer.new(temp_filename)
  instructions.process  

  File.delete(temp_filename)

  instructions
end

def collect_function_definitions(tritium)
  
  raw_functions = tritium.split("@func").compact
  raw_functions.delete_if {|function_string| function_string == "" }

  raw_functions.collect do |raw_function|
    function = ::Function.new

    raw_function, function.name = parse_name(raw_function)
    raw_function, function.args = parse_args(raw_function)
    function.instruction = parse_function(raw_function, get_function_signature(function) )

    function
  end
  
end


if !File.exists?(files[:input])
  puts "Missing input file: #{files[:input]}"
  exit(1)
end

tritium = File.read(files[:input])

functions = collect_function_definitions(tritium)

puts "Output: #{functions}"

# File.open(files[:output], "w") {|f| f << Beefcake.marshall(functions) }


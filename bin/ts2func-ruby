#!/usr/bin/env ruby

#require_relative "exec_init"
require "optparse"

$options = {}

OptionParser.new do |opts|
  opts.banner = "Usage: ts2func-ruby filename.ts filename.to"

  opts.on("-s", "--stdout", "Print to STDOUT") do |s|
    $options[:standard_out] = s
  end

  opts.on("-v", "--verbose", "Print debug messages") do |v|
    $options[:verbose] = v
  end

end.parse!


files = {}
files[:input] = ARGV[0] || ""
files[:output] = ARGV[1] || ""

require "beefcake"
require_relative '../lib/tritium'
require_relative '../lib/tritium/serializer/serializer'

def parse_name(raw_function) 

  parens_index = raw_function.index("(")

  if parens_index.nil?
    throw Exception.new("Error parsing function name. Raw tritium: #{raw_function}")
  end

  name = raw_function[0..parens_index-1].strip
  raw_function = raw_function[parens_index..-1]

  [raw_function, name.force_encoding("BINARY")]
end

def parse_args(raw_function) 

  args_begin = raw_function.index("(")
  args_end = raw_function.index(")", args_begin)
  
  args = raw_function[args_begin+1..args_end-1]
  raw_function = raw_function[args_end+1..-1]

  # Do I need to keep anything beyond the type?

  args = args.split(",").collect do |arg_string|

    arg = ::Function::Argument.new 

    arg_components = arg_string.split(" ")
    arg.type_string = arg_components.first.force_encoding("BINARY")
    arg.name = arg_components.last[1..-1].force_encoding("BINARY")
    
    arg
  end
  
  args.compact!

  [raw_function, args]
end

def get_function_signature(function)

  signature = function.name.dup
  
  function.args.each do |arg|
    signature << "." << arg.type_string unless arg.type_string.nil?
    signature << "." << arg.name unless arg.name.nil?
  end

  signature.force_encoding("BINARY")
end

def parse_function(tritium, signature)

  # Get the function body without the curly brackets:

  block_start = tritium.index("{")  
  block_end = tritium.index(/\}\s*?\Z/)

  block = tritium[block_start+1..block_end-1]

  ## Hack to fix %function_variables_like_this
  ## TODO(SJ): Update the parser to handle these correctly (HC says it should work)

  #block.gsub!(/\%(\w*?\W)/, "$function_\\1")

  # Now stuff the body into a tmp file so that I can re-use the ObjectSerializer
  
  puts "hacked tritium:\n#{block}" if $options[:verbose]

  temp_filename = signature + ".tmp"
  File.open(temp_filename, "w") {|f| f << block}

  parser = Tritium::Parser::Parser.new(temp_filename)
  ins = parser.parse

  instruction = ::Instruction.new
  instruction.type = ::Instruction::InstructionType::BLOCK
  instruction.children = Tritium::Serializer::ObjectSerializer.convert_instructions(ins.statements)

  File.delete(temp_filename)

  instruction
end

def collect_function_definitions(tritium)

  # Hack : Get rid of comments
  tritium.gsub!(/#[^\n]*\n/,"") 

  raw_functions = tritium.split("@func").compact
  raw_functions.delete_if {|function_string| function_string =~ /\A\s*\Z/m }

  function_array = ::FunctionArray.new

  function_array.functions = raw_functions.collect do |raw_function|
    function = ::Function.new

    raw_function, name = parse_name(raw_function)
    if name.include?(".")
      function.scope_type, function.name = name.split(".")
    else
      function.name = name
    end
    raw_function, function.args = parse_args(raw_function)
    function.instruction = parse_function(raw_function, get_function_signature(function) )

    if $options[:verbose]
      puts "-"*20
      puts "Function: #{function.name}"
      puts "raw tritium:\n#{raw_function}"
      puts "result:\n"
      p function
      puts "\n"
    end

    function
  end

  function_array

end


if !File.exists?(files[:input])
  puts "Missing input file: #{files[:input]}"
  exit(1)
end

tritium = File.read(files[:input])

functions = collect_function_definitions(tritium)

p functions if $options[:verbose] 

encoded_functions = functions.encode

print encoded_functions if $options[:standard_out]

File.open(files[:output], "wb") {|f| f.write(encoded_functions) }

# Now try and read the result:

if $options[:verbose]

  puts "-"*10

  fa = ::FunctionArray.decode(encoded_functions)
  # This is false because encoding removes empty optional fields
  # puts fa == functions 

  p fa

  result = File.read(files[:output])
  fab = ::FunctionArray.decode(result)

  puts "-"*5
  p fab
  puts fa == fab
  # I should put this into a test somewhere

end
